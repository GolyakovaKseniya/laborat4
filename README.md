# Задание 1
## Задача 1
### Текст задачи
Обобщенная коробка. Создайте сущность Коробка, которая обладает следующими характеристиками: • Может хранить один произвольный объект в один момент времени. • Объект можно получить и разместить на хранение в любой момент времени. • Если объект забирают из коробки – ссылку на этот объект необходимо обнулить. • Если объект кладут в коробку, но она не пуста – необходимо выкинуть исключение. • Имеет метод проверки на заполненность. • Методы класса должны работать с тем типом данных, который был указан во время создания объекта Создайте Коробку которая может хранить целочисленное значение, разместите туда число 3. Передайте Коробку в какой-либо метод, извлеките значение, и выведите его на экран.
### Алгоритм решения
Создаем обобщенный класс, то есть прописываем объявление типового переменной, приватное поле этого типа (оно будет заменено конкретным типом), создаем 2 конструктора с пустой коробкой и с содержимым. Далее, чтобы можно было поместить в коробку объект нужен метод, если коробка уже занята – выкидываем исключение. Далее получение объекта: очищаем коробку, то есть удаляем ссылку на вытащенный объект и возвращаем его. По условию нужны методы проверки на заполненность: делаем два – на пустоту и наличие объекта. И прописываем метод toString. Если коробка не пуста, то выводим, что она содержит. В методе main создаем коробки с конкретными типами, которые заменят типовую переменную. Далее если коробка пустая кладем объект, если обратное извлекаем. Можно вывести на экран состояние всех коробок.
#### Пример вывода
1) Текущее состояние: Коробка пуста
1 - Положить число
2 - Извлечь число
3 - Проверить заполненность
Ваш выбор: 1
Введите целое число: 3
Число добавлено: Коробка содержит: 3 (тип: Integer)
ВСЕ КОРОБКИ
Целочисленная: Коробка содержит: 3 (тип: Integer)
Строковая: Коробка пуста
Дробночисловая: Коробка пуста
Ваш выбор: 5
Текущее состояние целочисленной коробки: Коробка содержит: 3 (тип: Integer)
Извлечено из коробки в методе: 3
После работы метода: Коробка пуста
2) Ваш выбор: 1
Введите целое число: 3
Число добавлено: Коробка содержит: 3 (тип: Integer)
Ваш выбор: 1
Текущее состояние: Коробка содержит: 3 (тип: Integer)
1 - Положить число
2 - Извлечь число
3 - Проверить заполненность
Ваш выбор: 1
Ошибка: Коробка уже занята!


# Задание 1
## Задача 2
### Текст задачи
Без null. Создайте сущность Хранилище, которая обладает следующими характеристиками: • Может хранить один произвольный объект в один момент времени. • Хранилище неизменяемо. • Объект кладется в Хранилище при его создании. В качестве объекта может быть сохранено также и значение null. • Хранилище может вернуть ссылку на Объект. • Если вместо объекта хранится null, необходимо вернуть какое-либо альтернативное значение. • Метод получения значения должен работать с тем типом данных, который был указан во время создания объекта Выполните следующие задания: • Создайте Хранилище чисел, положите туда значение null. Передайте Хранилище в какой либо метод, извлеките значение, и выведите его на экран. Альтернативой должно быть число 0. • Создайте Хранилище чисел, положите туда значение 99. Передайте Хранилище в какой либо метод, извлеките значение, и выведите его на экран. Альтернативой должно быть число -1. • Создайте Хранилище строк, положите туда значение null. Передайте Хранилище в какой либо метод, извлеките значение, и выведите его на экран. Альтернативой должна быть строка “default”. • Создайте Хранилище строк, положите туда значение “hello”. Передайте Хранилище в какой-либо метод, извлеките значение, и выведите его на экран. Альтернативой должна быть строка “hello world”.
### Алгоритм решения
Создаем обобщенный класс, то есть прописываем объявление типового переменной, приватное final (по усл) поле этого типа (оно будет заменено конкретным типом), создаем конструктор с объектом. Далее прописываем метод для получения объекта: если хранилище содержит какое-то не null значение, то вернем ссылку на объект, иначе вернем какое-нибудь альтернативное значение того же типа, что и само хранилище. Прописываем проверку на пустоту. Метод toString выводит содержимое хранилища, если оно не пустое. В методе main изначально переменной присваиваем значение null, далее если нужно ввести определенное значение, то переприсваиваем и создаем хранилище с этим значением, далее вводим альтернативное и выводим результат. 
#### Пример вывода
1) 1 - Создать числовое хранилище
2 - Создать строковое хранилище
0 - Выход
Ваш выбор: 1
1 - Ввести число
2 - Использовать null
Ваш выбор: 1
Введите целое число: 99
Создано: Хранилище содержит: 99
Введите альтернативное значение (если null): -1
Результат: 99
Передача числового хранилища в метод
Исходное хранилище: Хранилище содержит: 99
Извлеченное значение: 99
2) 1 - Создать числовое хранилище
2 - Создать строковое хранилище
0 - Выход
Ваш выбор: 2
1 - Ввести текст
2 - Использовать null
Ваш выбор: 2
Создано: Хранилище содержит: null
Введите альтернативный текст: hello
Результат: hello
Передача строкового хранилища в метод
Исходное хранилище: Хранилище содержит: null
Извлеченное значение: hello

# Задание 2
## Задача 3
### Текст задачи
Начало отсчета. Создайте метод, принимающий Коробку из задачи 3.1.1, и кладет в неё трехмерную точку координат (из задачи 2.1.5) с произвольными значениями. Метод должен позволять передавать Коробку с более чем одним видом параметризации.
### Алгоритм решения
Создадим класс для этой задачи, пропишем приватное поле, позволяющее хранить любую коробу независимо от параметризации. В конструкторе создаем пустой список для хранения коробок. Далее необходимый метод, принимающий точку и коробку, параметризованную типом, являющимся точкой или другим типом, являющимся для нее родительским. Используем маску <? super> (нижняя граница), так как нам нужно именно записать точку в коробку. Далее пропишем метод добавления в коробку, который принимает коробку любого типа. В методе main создаем объект класса и коробки с разными типами и добавляем ее в список. Потом вводим все координаты и помещаем созданную точку в коробку. Можно вывести состояние всех коробок, а также извлечь все элементы.
#### Пример вывода
1) Введите координаты трехмерной точки (начало отсчета):
Координата X: 2
Координата Y: -3
Координата Z: 1
Точка (2,00, -3,00, 1,00) помещена в коробку для Point3D
СОСТОЯНИЕ КОРОБОК: 
1 - Коробка содержит: (2,00, -3,00, 1,00) (тип: Point3D)
2 - Коробка пуста
1. Из коробки для Point3D: 
Извлечена точка: (2,00, -3,00, 1,00)
Координаты: X=2.0, Y=-3.0, Z=1.0
2. Из коробки для Object: 
Коробка пуста
2) Введите координаты трехмерной точки (начало отсчета):
Координата X: 3
Координата Y: 3
Координата Z: 3
Точка (3,00, 3,00, 3,00) помещена в коробку для Object
СОСТОЯНИЕ КОРОБОК: 
1 - Коробка пуста
2 - Коробка содержит: (3,00, 3,00, 3,00) (тип: Point3D)
1. Из коробки для Point3D: 
Коробка пуста
2. Из коробки для Object: 
Извлечена точка: (3,00, 3,00, 3,00)
Координаты: X=3.0, Y=3.0, Z=3.0

# Задание 3
## Задача 1
### Текст задачи
Функция. Разработайте такой метод, который будет принимать список значений типа T, и объект имеющий единственный метод apply. Данный метод надо применить к каждому элементу списка, и вернуть новый список значений типа P, при этом типы T и P могут совпадать, а могут не совпадать. Используйте разработанный метод следующим образом: 1. Передайте в метод список со значениями:“qwerty”, “asdfg”, “zx”, а получите список чисел, где каждое число соответствует длине каждой строки. 2. Передайте в метод список со значениями: 1,-3,7, а получите список в котором все отрицательные числа стали положительными, а положительные остались без изменений 3. Передайте в метод список состоящий из массивов целых чисел, а получите список в котором будут только максимальные значения каждого из исходных массивов
### Алгоритм решения
Создаем обобщенный метод, принимающий исходный список значений типа Т и объект (интерфейс) function, который имеет единственный метод apply. Этот метод преобразует один тип в другой. Созданный метод должен возвращать новый список типа Р, поэтому создаем его. Проходим по всем элементам исходного списка и вызываем метод apply, далее добавляем в новый список преобразованный элемент, возвращаем новый список. В методе main создаем новые списки с конкретным типом, далее вводим необходимые данные. И далее для нового списка вызываем наш метод с авто выводом типов. 
#### Пример вывода
1) Введите количество строк: 3
Введите строку 1: qwerty
Введите строку 2: asdfg
Введите строку 3: zx
Результат:
Исходные строки: [qwerty, asdfg, zx]
Длины строк: [6, 5, 2]
2) Введите количество чисел: 3
Введите числа (положительные и отрицательные):
Число 1: 1
Число 2: -3
Число 3: 7
Результат:
Исходные числа: [1, -3, 7]
Абсолютные значения: [1, 3, 7]
3) Введите количество массивов: 2
Введите размер массива 1: 4
Введите элементы массива 1: 1,2,3,4
Введите размер массива 2: 2
Введите элементы массива 2: 1,9
Результат:
Исходные массивы:
Массив 1: [1, 2, 3, 4]
Массив 2: [1, 9]
Максимальные значения: [4, 9]


# Задание 3
## Задача 2
### Текст задачи
Фильтр. Разработайте такой метод, который будет принимать список значений типа T и объект имеющий единственный метод test (принимает T и возвращает boolean). Верните новый список типа T, из которого удалены все значения не прошедшие проверку условием. Используйте разработанный метод следующим образом: 1. Передайте в метод список со значениями: “qwerty”, “asdfg”, “zx”, и отфильтруйте все строки имеющие менее трех символов 2. Передайте в метод список со значениями: 1,-3,7, и отфильтруйте все положительные элементы 3. Передайте в метод список состоящий из массивов целых чисел, а получите список в котором будут только те массивы, в которых нет ни одного положительного элемента
### Алгоритм решения
Создаем обобщенный метод, принимающий исходный список типа Т и интерфейс Predicate, имеющий единственный метод test, который возвращает true, если элемент удовлетворяет условию. В нем создаем новый список того же типа, так как фильтрация не его меняет. Проходим по элементам исходного списка и если он удовлетворяет условию, то добавляем его в новый список. В методе main создаем новые списки с конкретным типом, далее вводим необходимые данные. И далее для нового списка вызываем наш метод с авто выводом типов.
#### Пример вывода
1) Введите количество строк: 3
Введите строку 1: qwerty
Введите строку 2: asdfg
Введите строку 3: zx
Результат фильтрации:
Исходный список: [qwerty, asdfg, zx]
Отфильтрованный список: [qwerty, asdfg]
2) Введите количество чисел: 3
Введите числа (положительные и отрицательные):
Число 1: 1
Число 2: -3
Число 3: 7
Результат фильтрации:
Исходный список: [1, -3, 7]
Отфильтрованный список: [-3]
3) Введите количество массивов: 2
Введите размер массива 1: 2
Введите элементы массива 1: 0, -5
Введите размер массива 2: 2
Введите элементы массива 2: 1, 4
Результат фильтрации:
Исходные массивы:
Массив 1: [0, -5]
Массив 2: [4, 1]
Отфильтрованные массивы (без положительных элементов):
Массив 1: [0, -5]

# Задание 3
## Задача 3
### Текст задачи
Сокращение. Разработайте такой метод, который будет принимать список значений типа T и способ с помощью которого список значений можно свести к одному значению типа T, которое и возвращается из метода. Используйте разработанный метод следующим образом: 1. Передайте в метод список со значениями: “qwerty”, “asdfg”, “zx”, и сформируйте одну большую строку, которая состоит из всех строк исходного списка. 2. Передайте в метод список со значениями: 1,-3,7, и верните сумму всех значений исходного списка. 3. Имеется список, состоящий из списков целых чисел, получите общеe количество элементов во всех списках. Подсказка: решить задачу можно в одно действие или последовательно использовать методы из 3.3.1 и 3.3.3. Далее необходимо изменить разработанный метод таким образом, чтобы данный метод гарантированно не возвращал null и не выбрасывал ошибок в том случае, если исходный список пуст.
### Алгоритм решения
Создаем обобщенный метод, принимающий исходный список типа Т, интерфейс BinaryOperator, содержащий метод apply, который принимает два элемента и возвращает один, и значение по умолчанию для пустого списка. В методе смотрим, если список пуст, то возвращаем значение по умолч. Далее берем 1 элемент, потом со 2 элемента объединяем текущий результат со следующим элементом. И возвращаем итоговый результат. В методе main создаем новые списки с конкретным типом, далее вводим необходимые данные. И далее вызываем наш метод с авто выводом типов.
#### Пример вывода
1) Введите количество строк: 3
Введите строку 1: йцукен
Введите строку 2: фывап
Введите строку 3: яч
Результат сокращения:
Исходный список: [йцукен, фывап, яч]
Объединенная строка: "йцукенфывапяч"
2) Число 1: 1
Число 2: -3
Число 3: 7
Результат:
Исходные числа: [1, -3, 7]
Сумма: 5
3) Введите количество вложенных списков: 2
Введите количество элементов в списке 1: 3
Введите элементы списка 1: 1, 4, 6
Введите количество элементов в списке 2: 2
Введите элементы списка 2: 3, 9
Результат сокращения:
Исходные списки:
Список 1: [1, 4, 6]
Список 2: [3, 9]
Общее количество элементов: 5

# Задание 3
## Задача 4
### Текст задачи
Коллекционирование. Разработайте такой метод, который будет возвращать коллекцию типа P со значениями типа T. Данный метод будет принимать: 1. Список исходных значений 2. Способ создания результирующей коллекции 3. Способ передачи значений исходного списка в результирующую коллекцию. Используйте разработанный метод следующим образом: 1. Передайте в метод список со значениями: 1,-3,7, и верните их разбитыми на два подсписка, в одном из которых будут только положительные числа, а в другом только отрицательные. 2. Передайте в метод список со значениями: “qwerty”, “asdfg”, “zx”, “qw” и верните их разбитыми на подсписки таким образом, чтобы в любом подсписке были строки только одинаковой длины 3. Передайте в метод список со значениями: “qwerty”, “asdfg”, “qwerty”, “qw” и верните набор такого вида, который не может содержать одинаковые объекты.
### Алгоритм решения
Создаем обобщенный метод с 2 типовыми параметрами (Т и Р, причем Р должен быть коллекцией с элементами типа Т или его подтипом), принимающий исходный список типа Т, интерфейс Supplier, с помощью которого создаем новые коллекции, и function для условия передачи элементов. В методе создаем новую коллекцию, далее проходим по всем элементам исходного списка и если элемент проходит условие, то добавляем его. Возвращаем коллекцию. В методе main создаем новые списки с конкретным типом, далее вводим необходимые данные. И далее вызываем наш метод с авто выводом типов.
#### Пример вывода
1) Введите количество чисел: 3
Введите числа:
Число 1: 1
Число 2: -3
Число 3: 7
Результат разделения:
Исходные числа: [1, -3, 7]
Положительные числа: [1, 7]
Отрицательные числа: [-3]
2) Введите количество строк: 3
Введите строку 1: qwerty
Введите строку 2: zx
Введите строку 3: qw
Результат группировки:
Исходные строки: [qwerty, zx, qw]
Строки длиной 2: [zx, qw]
Строки длиной 6: [qwerty]
3) Ваш выбор: 3
Введите количество строк: 3
Введите строку 1: qwerty
Введите строку 2: asdfg
Введите строку 3: qwerty
Результат:
Исходные строки: [qwerty, asdfg, qwerty]
Уникальные строки: [qwerty, asdfg]
